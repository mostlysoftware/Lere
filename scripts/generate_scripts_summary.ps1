<#
.SYNOPSIS
Generates a stable repository script summary (SCRIPTS.md) from inline comments and comment-based help.

.DESCRIPTION
Scans the repository for PowerShell scripts and Markdown files, extracts a short summary from the comment-based help
or leading comment block (for .ps1) and the first heading (for .md), and writes a well-formatted `SCRIPTS.md` at the
repository root. The writer is atomic (writes to a temp file then replaces) to avoid partially-written outputs.

.PARAMETER Root
The repository root to scan. Defaults to the repository root inferred from the script location.

.PARAMETER OutFile
Full path to the output README / SCRIPTS.md. Defaults to <repo-root>/SCRIPTS.md.

.PARAMETER Force
Overwrite the target file if it exists.

.EXAMPLE
.
  .\scripts\generate_scripts_summary.ps1 -OutFile .\SCRIPTS.md -Force

.NOTES
Creates a markdown table with Path | Type | Summary. Excludes common binary or IDE folders (\.git, node_modules, .vs).
#>

param(
    [string]$Root = (Resolve-Path -Path (Join-Path -Path (Split-Path -Path $MyInvocation.MyCommand.Path -Parent) -ChildPath '..')).Path,
    [string]$OutFile = (Resolve-Path -Path (Join-Path -Path (Join-Path -Path (Split-Path -Path $MyInvocation.MyCommand.Path -Parent) -ChildPath '..') -ChildPath 'SCRIPTS.md')).Path,
    [switch]$Force
)

Set-StrictMode -Version Latest

function Get-SummaryFromPs1 {
    param($File)
    $text = Get-Content -Raw -ErrorAction SilentlyContinue $File.FullName
    if (-not $text) { return '' }

    # Try to extract comment-based help block: <# ... #>
    if ($text -match '(?ms)<#(.*?)#>') {
        $block = $Matches[1].Trim()
        # Try to find .SYNOPSIS line inside the help
        if ($block -match '(?m)^[ \t]*\.SYNOPSIS[ \t]*(.*)$') { return $Matches[1].Trim() }
        # Fallback to the first non-empty line
        $first = ($block -split "\r?\n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })[0]
        return $first -replace '\s+', ' '
    }

    # Fallback: grab leading single-line comments starting with '#'
    $lines = Get-Content -Raw $File.FullName -ErrorAction SilentlyContinue -Encoding UTF8 | Out-String
    $leading = @()
    foreach ($line in ($lines -split "\r?\n")) {
        if ($line -match '^[ \t]*#') { $leading += ($line -replace '^[ \t]*#[ \t]*', '') }
        elseif ($line -match '^[ \t]*$') { if ($leading.Count -gt 0) { break } else { continue } }
        else { break }
    }
    if ($leading.Count -gt 0) { return ($leading -join ' ') -replace '\s+', ' ' }
    return ''
}

function Get-SummaryFromMd {
    param($File)
    $first = Get-Content -Raw -ErrorAction SilentlyContinue $File.FullName | Out-String
    if ($first -match '(?m)^[#]{1,6}\s+(.*)$') { return $Matches[1].Trim() }
    # Fallback: first non-empty line
    $line = (Get-Content -Path $File.FullName -ErrorAction SilentlyContinue | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })[0]
    return $line -replace '\s+', ' '
}

try {
    $rootPath = Resolve-Path -LiteralPath $Root -ErrorAction Stop
} catch {
    Write-Error "Cannot resolve root path: $Root"
    exit 2
}

$excludes = @('\.git\\','node_modules\\','\\.vs\\','\\dist\\','\\bin\\','\\obj\\')

$files = Get-ChildItem -Path $rootPath -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Extension -in '.ps1','.md' }
$files = $files | Where-Object {
    $skip = $false
    foreach ($pattern in $excludes) { if ($_.FullName -match $pattern) { $skip = $true; break } }
    -not $skip
}

$rows = @()
foreach ($f in $files | Sort-Object FullName) {
    $type = if ($f.Extension -eq '.ps1') { 'PowerShell' } else { 'Markdown' }
    if ($f.Extension -eq '.ps1') { $summary = Get-SummaryFromPs1 -File $f } else { $summary = Get-SummaryFromMd -File $f }
    if ([string]::IsNullOrWhiteSpace($summary)) { $summary = '' }
    $rel = $f.FullName.Substring($rootPath.Path.Length).TrimStart('\','/')
    $rows += [PSCustomObject]@{ Path = $rel; Type = $type; Summary = $summary }
}

$time = (Get-Date).ToString('u')
$builder = @()
$builder += "# Scripts and Documentation Summary"
$builder += ""
$builder += "Generated: $time"
$builder += ""
$builder += "This file was generated by `scripts/generate_scripts_summary.ps1`. It lists scripts and short summaries extracted from comment-based help or leading comments."
$builder += ""
$builder += "| Path | Type | Summary |"
$builder += "| ---- | ---- | ------- |"
foreach ($r in $rows) {
    $pathEsc = $r.Path -replace '\|','\|' # minimal escaping
    $summaryEsc = ($r.Summary -replace '\|','\|') -replace '\r?\n',' '
    $builder += "| $pathEsc | $($r.Type) | $summaryEsc |"
}

# Atomic write: write to temp then move
$temp = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "SCRIPTS.md.$([System.Diagnostics.Process]::GetCurrentProcess().Id).tmp")
try {
    $builder -join "`r`n" | Out-File -FilePath $temp -Encoding UTF8 -Force
    if ((Test-Path $OutFile) -and (-not $Force)) {
        Write-Error "$OutFile already exists. Use -Force to overwrite."
        Remove-Item -Force -ErrorAction SilentlyContinue $temp
        exit 3
    }
    Move-Item -Path $temp -Destination $OutFile -Force
    Write-Output "Wrote: $OutFile (items: $($rows.Count))"
} catch {
    if (Test-Path $temp) { Remove-Item -Force $temp -ErrorAction SilentlyContinue }
    Write-Error "Failed to write $OutFile : $_"
    exit 4
}

exit 0
